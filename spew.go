// Package spew provides a set of middlewares for the KrakenD framework ready to start dumping
// (pretty printed) request and response pairs into files
//
package spew

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"net/http/httputil"
	"path"
	"sync"
	"time"

	"github.com/davecgh/go-spew/spew"
	"github.com/devopsfaith/krakend/config"
	"github.com/devopsfaith/krakend/logging"
	"github.com/devopsfaith/krakend/proxy"
	"github.com/devopsfaith/krakend/transport/http/client"
)

// New returns a proxy middleware ready to start dumping all the requests and responses
// it processes.
func New(logger logging.Logger, name string, dumper Dumper) proxy.Middleware {
	return func(next ...proxy.Proxy) proxy.Proxy {
		switch len(next) {
		case 0:
			panic(proxy.ErrNotEnoughProxies)
		case 1:
		default:
			panic(proxy.ErrTooManyProxies)
		}
		return func(ctx context.Context, req *proxy.Request) (*proxy.Response, error) {
			resp, err := next[0](ctx, req)

			logger.Debug("spew: capturing request and response at the", name, "layer")
			dumper.Dump(name, req, resp, err)

			return resp, err
		}
	}
}

// ProxyFactory returns a proxy.FactoryFunc over the received proxy.FactoryFunc with a spew middleware wrapping
// the generated pipe
func ProxyFactory(logger logging.Logger, factory proxy.Factory, df DumperFactory) proxy.FactoryFunc {
	dumper := df(SpewFormater)

	return func(cfg *config.EndpointConfig) (proxy.Proxy, error) {
		p, err := factory.New(cfg)
		if err != nil {
			return p, err
		}

		name := "proxy_" + base64.URLEncoding.EncodeToString([]byte(cfg.Endpoint))
		mw := New(logger, name, dumper)
		return mw(p), nil
	}
}

// BackendFactory returns a proxy.BackendFactory over the received proxy.BackendFactory with a spew middleware wrapping
// the generated backend
func BackendFactory(logger logging.Logger, factory proxy.BackendFactory, df DumperFactory) proxy.BackendFactory {
	dumper := df(SpewFormater)

	return func(backend *config.Backend) proxy.Proxy {
		name := "backend_" + base64.URLEncoding.EncodeToString([]byte(backend.URLPattern))
		mw := New(logger, name, dumper)
		return mw(factory(backend))
	}
}

// ClientFactory decorates the transport of the client generated by the received factory with a Transport
func ClientFactory(l logging.Logger, f client.HTTPClientFactory, df DumperFactory) client.HTTPClientFactory {
	sd := df(SpewFormater)
	pd := df(PlainClientFormater)

	return func(ctx context.Context) *http.Client {
		c := f(ctx)

		next := c.Transport

		if next == nil {
			next = http.DefaultTransport
		}

		c.Transport = &Transport{
			Transport: next,
			Logger:    l,
			Spew:      sd,
			Plain:     pd,
		}

		return c
	}
}

// Transport is a wrapper over an instance of http.RoundTripper. It dumps every pair of request
// and response into two dumpers: one using the spew lib; the second using the httputil package from the standard lib
type Transport struct {
	Transport http.RoundTripper
	Logger    logging.Logger
	Spew      Dumper
	Plain     Dumper
}

// RoundTrip takes a Request and returns a Response
//
// It delegates the actual execution and it just dumps the request, the response and the possible
// error
func (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {
	resp, err = t.Transport.RoundTrip(req)

	t.Logger.Debug("spew: capturing http request and response at the client layer")

	name := base64.URLEncoding.EncodeToString([]byte(req.URL.String()))
	t.Plain.Dump("client_plain_"+name, req, resp, err)
	t.Spew.Dump("client_"+name, req, resp, err)

	return
}

// RunServerFunc is the interface expected by all the KrakenD http routers
type RunServerFunc func(context.Context, config.ServiceConfig, http.Handler) error

// RunServer returns a wrapper over the received RunServerFunc so it can inject a decorated
// http.Handler and dump pairs of request and response using the generated dumper.
func RunServer(l logging.Logger, f RunServerFunc, df DumperFactory) RunServerFunc {
	sd := df(SpewFormater)
	pd := df(PlainServerFormater)

	return func(ctx context.Context, cfg config.ServiceConfig, handler http.Handler) error {
		h := http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			w := httptest.NewRecorder()
			handler.ServeHTTP(w, req)
			for k, vs := range w.Header() {
				for _, v := range vs {
					rw.Header().Add(k, v)
				}
			}
			resp := w.Result()
			rw.WriteHeader(resp.StatusCode)

			body, err := ioutil.ReadAll(resp.Body)
			if err == nil {
				rw.Write(body)
				resp.Body.Close()
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(body))
			}

			name := base64.URLEncoding.EncodeToString([]byte(req.URL.String()))

			l.Debug("spew: capturing http request and response at the router layer")
			sd.Dump("router_"+name, req, rw, nil)
			pd.Dump("router_plain_"+name, req, resp, nil)
		})
		return f(ctx, cfg, h)
	}
}

// Dumper is the interface for the structs responsibles of persisting the inspected pair req/resp after formating them
type Dumper interface {
	Dump(id string, req interface{}, resp interface{}, err error)
}

// DumperFactory is the signature of a function that returns a dumper with the received formater injected.
type DumperFactory func(formater Formater) Dumper

// NewFileDumperFactory creates a DumperFactory for building dumpers writing the intercepted data as txt into the filesystem.
//
// The txt files will be stored in the path defined by the output argument, using the name argument
// as a prefix, so a pair request and response named "xxx" will be stored in the output folder as xxx_{timestamp}.txt
func NewFileDumperFactory(ctx context.Context, path string, l logging.Logger) DumperFactory {
	once.Do(func() {
		fileFlusher = flusher{in: make(chan dumpedItem, 100)}
		for i := 0; i < fileWriterWorkers; i++ {
			go fileFlusher.consume(ctx, l)
		}
	})
	return func(formater Formater) Dumper {
		return &fileDumper{
			path:     path,
			l:        l,
			formater: formater,
			out:      fileFlusher.in,
		}
	}
}

type fileDumper struct {
	path     string
	l        logging.Logger
	formater Formater
	out      chan dumpedItem
}

func (f *fileDumper) Dump(name string, req interface{}, resp interface{}, err error) {
	d := dumpedItem{
		path:    fmt.Sprintf("%s_%d.txt", path.Join(f.path, name), time.Now().UnixNano()),
		content: f.formater(req, resp, err),
		l:       f.l,
	}
	select {
	case f.out <- d:
	default:
	}
}

// Formater is the signature of a function that transform the inspected data into a byte array representation
type Formater func(req interface{}, resp interface{}, err error) []byte

// SpewFormater is a function that dumps the inspected data using the spew lib
func SpewFormater(req interface{}, resp interface{}, err error) []byte {
	bf := new(bytes.Buffer)

	writeHeader(bf, "Request")
	spew.Fdump(bf, req)

	writeHeader(bf, "Response")
	spew.Fdump(bf, resp)

	writeHeader(bf, "error")
	spew.Fdump(bf, err)

	return bf.Bytes()
}

// PlainClientFormater is a function that dumps the inspected data (at the client level) using the httputil lib
func PlainClientFormater(req interface{}, resp interface{}, err error) []byte {
	in := new(bytes.Buffer)

	writeHeader(in, "Request")
	dump, _ := httputil.DumpRequestOut(req.(*http.Request), true)
	in.Write(dump)

	writeHeader(in, "Response")
	if r, ok := resp.(*http.Response); ok && r != nil {
		dump2, _ := httputil.DumpResponse(r, true)
		in.Write(dump2)
	}

	writeHeader(in, "error")
	if err != nil {
		in.Write([]byte(err.Error()))
	}

	return in.Bytes()
}

// PlainServerFormater is a function that dumps the inspected data (at the router level) using the httputil lib
func PlainServerFormater(req interface{}, resp interface{}, err error) []byte {
	in := new(bytes.Buffer)

	writeHeader(in, "Request")
	dump, _ := httputil.DumpRequest(req.(*http.Request), true)
	in.Write(dump)

	writeHeader(in, "Response")
	if r, ok := resp.(*http.Response); ok && r != nil {
		dump2, _ := httputil.DumpResponse(r, true)
		in.Write(dump2)
	}

	writeHeader(in, "error")
	if err != nil {
		in.Write([]byte(err.Error()))
	}

	return in.Bytes()
}

const lineSeparation = "\n*************************************************************\n"

func writeHeader(w io.Writer, msg string) {
	w.Write([]byte(lineSeparation + msg + lineSeparation))
}

type dumpedItem struct {
	path    string
	content []byte
	l       logging.Logger
}

var (
	fileFlusher       flusher
	once              = new(sync.Once)
	fileWriterWorkers = 5
)

type flusher struct {
	in chan dumpedItem
}

func (f flusher) consume(ctx context.Context, l logging.Logger) {
	for {
		select {
		case <-ctx.Done():
			return
		case i := <-f.in:
			if err := ioutil.WriteFile(i.path, i.content, 0666); err != nil && i.l != nil {
				l.Error("spew: writing the captured data:", err.Error())
			}
		}
	}
}
