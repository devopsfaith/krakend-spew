package http

import (
	"bytes"
	"context"
	"encoding/base64"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"net/http/httputil"

	"github.com/devopsfaith/krakend/config"
	"github.com/devopsfaith/krakend/logging"
	"github.com/devopsfaith/krakend/transport/http/client"

	spew "github.com/devopsfaith/krakend-spew"
)

// ClientFactory decorates the transport of the client generated by the received factory with a Transport
func ClientFactory(l logging.Logger, f client.HTTPClientFactory, df spew.DumperFactory) client.HTTPClientFactory {
	sd := df(spew.SpewFormater)
	pd := df(PlainClientFormater)

	return func(ctx context.Context) *http.Client {
		c := f(ctx)

		next := c.Transport

		if next == nil {
			next = http.DefaultTransport
		}

		c.Transport = &Transport{
			Transport: next,
			Logger:    l,
			Spew:      sd,
			Plain:     pd,
		}

		return c
	}
}

// Transport is a wrapper over an instance of http.RoundTripper. It dumps every pair of request
// and response into two dumpers: one using the spew lib; the second using the httputil package from the standard lib
type Transport struct {
	Transport http.RoundTripper
	Logger    logging.Logger
	Spew      spew.Dumper
	Plain     spew.Dumper
}

// RoundTrip takes a Request and returns a Response
//
// It delegates the actual execution and it just dumps the request, the response and the possible
// error
func (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {
	reqToSave := cloneRequest(req)
	resp, err = t.Transport.RoundTrip(req)

	name := base64.URLEncoding.EncodeToString([]byte(reqToSave.URL.String()))
	t.Plain.Dump("client_plain_"+name, reqToSave, resp, err)
	t.Spew.Dump("client_"+name, reqToSave, resp, err)

	return
}

// RunServerFunc is the interface expected by all the KrakenD http routers
type RunServerFunc func(context.Context, config.ServiceConfig, http.Handler) error

// RunServer returns a wrapper over the received RunServerFunc so it can inject a decorated
// http.Handler and dump pairs of request and response using the generated dumper.
func RunServer(l logging.Logger, f RunServerFunc, df spew.DumperFactory) RunServerFunc {
	sd := df(spew.SpewFormater)
	pd := df(PlainServerFormater)

	return func(ctx context.Context, cfg config.ServiceConfig, handler http.Handler) error {
		h := http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			reqToSave := cloneRequest(req)
			w := httptest.NewRecorder()
			handler.ServeHTTP(w, req)
			for k, vs := range w.Header() {
				for _, v := range vs {
					rw.Header().Add(k, v)
				}
			}
			resp := w.Result()
			rw.WriteHeader(resp.StatusCode)

			body, err := ioutil.ReadAll(resp.Body)
			if err == nil {
				rw.Write(body)
				resp.Body.Close()
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(body))
			}

			name := base64.URLEncoding.EncodeToString([]byte(reqToSave.URL.String()))

			sd.Dump("router_"+name, reqToSave, rw, nil)
			pd.Dump("router_plain_"+name, reqToSave, resp, nil)
		})
		return f(ctx, cfg, h)
	}
}

// PlainClientFormater is a function that dumps the inspected data (at the client level) using the httputil lib
func PlainClientFormater(req interface{}, resp interface{}, err error) []byte {
	in := new(bytes.Buffer)

	writeHeader(in, "Request")
	dump, _ := httputil.DumpRequestOut(req.(*http.Request), true)
	in.Write(dump)

	writeHeader(in, "Response")
	if r, ok := resp.(*http.Response); ok && r != nil {
		dump2, _ := httputil.DumpResponse(r, true)
		in.Write(dump2)
	}

	writeHeader(in, "error")
	if err != nil {
		in.Write([]byte(err.Error()))
	}

	return in.Bytes()
}

// PlainServerFormater is a function that dumps the inspected data (at the router level) using the httputil lib
func PlainServerFormater(req interface{}, resp interface{}, err error) []byte {
	in := new(bytes.Buffer)

	writeHeader(in, "Request")
	dump, _ := httputil.DumpRequest(req.(*http.Request), true)
	in.Write(dump)

	writeHeader(in, "Response")
	if r, ok := resp.(*http.Response); ok && r != nil {
		dump2, _ := httputil.DumpResponse(r, true)
		in.Write(dump2)
	}

	writeHeader(in, "error")
	if err != nil {
		in.Write([]byte(err.Error()))
	}

	return in.Bytes()
}

const lineSeparation = "\n*************************************************************\n"

func writeHeader(w io.Writer, msg string) {
	w.Write([]byte(lineSeparation + msg + lineSeparation))
}

func cloneRequest(req *http.Request) *http.Request {
	res, err := http.NewRequest(req.Method, req.URL.String(), nil)
	if err != nil {
		return nil
	}
	if req.Body != nil && req.Body != http.NoBody {
		var buf bytes.Buffer
		if _, err = buf.ReadFrom(req.Body); err != nil {
			return nil
		}
		if err = req.Body.Close(); err != nil {
			return nil
		}
		req.Body = ioutil.NopCloser(&buf)
		res.Body = ioutil.NopCloser(bytes.NewReader(buf.Bytes()))
		res.ContentLength = req.ContentLength
	}

	for k, vs := range req.Header {
		for _, v := range vs {
			res.Header.Add(k, v)
		}
	}

	return res
}
